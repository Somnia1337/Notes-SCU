## 1. 超类与子类

继承的基本思想是，基于已有类创建新类，新类继承已有类的成员，并新增成员以适应不同情况。

对Employee，假设员工分为普通员工与管理人员，后者拥有奖金，那么可以创建一个新类Manager，继承Employee的成员，新增`salary`字段及相关成员。每个管理人员都是员工，它们的关系为“是”("is-a")。

### 1) 继承层次结构

**继承层次结构**(inheritance hierarchy)：由一个公共父类派生出来的所有类的集合。

**继承链**(inheritance chain)：在继承层次结构中，从某个特定的类到其祖先的路径。

一个祖先类可以有多个子孙链，不同链上的子类之间没有关系。

### 2) 子类

**关键字extends**：表示继承关系。

```Java
public class Manager extends Employee
{
	/*新增成员*/
	...
}
```

extends指示正在构造的新类继承一个已存在的类，后者称为**超类**(superclass)/**基类**(base class)/**父类**(parent class)，新类称为**子类**(subclass/child class)/**派生类**(derived class)。

```Java
public class Manager extends Employee
{
	private double bonus;
	...
	public void setBonus(double bonus)
	{
		this.bonus = bonus;
	}
}
```

==子类不能访问父类的私有字段==。

==记录不能继承或被继承==。

### 3) 覆盖方法

Manager中，方法getSalary应该返回薪水与奖金之和，为此需要在Manager中提供同名方法Manager.getSalary来**覆盖**(override)Employee.getSalary。

```Java
public double getSalary()
{
	return salary + bonus; //ERROR：子类不能访问父类的私有字段
}

public double getSalary()
{
	double baseSalary = getSalary(); //无限循环调用自身
	return baseSalary + bonus;
}
```

**关键字super**：指示调用父类中的方法（而非子类中的同名方法）。例如，调用`super.getSalary()`将调用Employee.getSalary。

```Java
/*Manager.getSalary的定义*/
public double getSalary()
{
	double baseSalary = super.getSalary();
	return baseSalary + bonus;
}
```

在覆盖方法时，==子类方法的可见度不能低于父类方法==，如果后者标记public，前者也必须标记public。

### 4) 子类构造器

子类构造器==必须在首条语句调用父类构造器==（除非父类有无参构造器）。

```Java
/*Manager的构造器*/
public Manager(String name, double salary, int year, int month, int day)
{
	super(name, salary, year, month, day); //调用父类中参数为name，salary，year，month，day的构造器
	bonus = 0;
}
```

```Java
/*父类与子类的使用*/
Manager boss = new Manager("Jane", 8000, 2012, 11, 9);
boss.setBonus(3000);

var staff = new Employee[3];
staff[0] = boss;
staff[1] = new Employee(...);
staff[2] = new Employee(...);

for (Employee e : staff)
	System.out.println(e.getName() + " " + e.getSalary());
```

对调用`e.getSalary()`，编译器将自动选出正确的getSalary，尽管将`e`声明为Employee类型，但是它实际上既可以引用Employee对象，也可以引用其子类Manager对象。

一个对象变量可以指示多种实际类型的特性称为**多态**(polymorphism)，在运行时能够自动选择适当方法的机制称为**动态绑定**(dynamic binding)。

### 5) 多态

上例中，`boss`与`staff[0]`引用同一个Manager对象，但编译器只认为`staff[0]`引用一个Employee对象，所以，可以调用`boss.setBonus(3000)`，但不能调用`staff[0].setBonus(3000)`。

==不能将父类对象引用赋给子类变量==，例如`Manager m = staff[0]`非法。

### 6) 方法调用

假设调用`x.f(args)`，隐式参数`x`为C类的一个对象，以下为调用步骤：

1. 编译器查看对象的声明类型与方法名。可能存在多个名为f但参数类型不同的方法，编译器将列举C及其父类中所有名为f且可访问的方法（父类的私有方法不可访问）。
2. 编译器确定方法调用中提供的参数类型。此过程称为**重载解析**(overloading resolution)，由于类型转换，情况可能很复杂。如果没有找到参数类型匹配的方法或者类型转换后有多个方法匹配，将报错。
3. 如果该方法或构造器为private/static/final，编译器将准确地知道需要调用的方法，这称为**静态绑定**(static binding)。与之相对，如果要调用的方法依赖于隐式参数的实际类型，那么运行时采用动态绑定。
4. 采用动态绑定调用方法时，JVM调用与`x`所引用对象实际类型对应的方法。假设`x`的实际类型为为C的子类D，如果D定义了方法f(String)，将调用它，否则将在C及其父类中寻找同名方法。

每次调用方法都要完成这个搜索过程，时间开销很大，为此JVM预先为每个类计算了一张**方法表**(method table)，其中列出了所有方法的签名和要调用的实际方法。

### 7) final类与方法

**final类**：==不允许继承==的类。

```Java
/*final类的声明*/
public final class Executive extends Manager
{
	...
}
```

**final方法**：==不允许覆盖==的方法。

```Java
/*final方法的声明*/
public class Employee
{
	...
	public final String getName()
	{
		return name;
	}
	...
}
```

==final类中的方法自动为final方法==。

如果一个方法没有被覆盖并且很短，编译器将对它进行优化处理，该过程称为**内联**(inlining)，例如，内联调用`e.getName()`将被替换为访问字段`e.name`。

JVM中的即时编译器处理能力更强，它将知道有哪些类继承自其他类，并且能检查其中的方法是否被覆盖，如果方法很简短、被频繁调用并且未被覆盖，即时编译器将对它内联。

### 8) 强制类型转换

```Java
Manager boss = new Manager("Jane", 8000, 2012, 11, 9);
boss.setBonus(3000);

var staff = new Employee[3];
staff[0] = boss;
staff[1] = new Employee(...);
staff[2] = new Employee(...);
```

这是上文的代码，事先声明Manager类型的`boss`，再将其存入Employee对象数组`staff`。现在改为在`staff`中构造该Manager对象：

```Java
var staff = new Employee[3];
staff[0] = new Manager("Jane", 8000, 2012, 11, 9);
staff[1] = new Employee(...);
staff[2] = new Employee(...);
```

`staff[0]`引用一个Manager对象，但其类型为Employee对象，为了访问Manager的字段`bonus`，需将`staff[0]`强制转换为Manager对象：

```Java
Manager boss = (Manager) staff[0];
```

将值存入变量时，编译器将检查情况：

- 将子类引用赋给父类变量，允许通过。
- ==将父类引用赋给子类变量，必须进行强制类型转换==。

试图将一个事实父类对象强制转换为子类对象时，将抛出ClassCastException：

```Java
Manager boss = (Manager) staff[1]; //ClassCastException
```

**操作符instanceOf**：检查对象是否属于指定类。

```Java
/*instanceOf的使用*/
if (staff[i] instanceOf Manager)
{
	boss = (Manager) staff[i];
	boss.setBonus(3000);
}
```

在将父类对象强制转换为子类对象前，必须进行instanceOf检查。

### 9) instanceOf模式匹配

以上代码较为冗长，在Java 16以上可以简写为：

```Java
if (staff[i] instanceOf Manager boss) boss.setBonus(3000);
```

如果`staff[i]`为Manager对象，则将`boss`设置为`staff[i]`，避免了强制转换。

无意义的instanceOf模式将出错：

```Java
Manager boss = new Manager(...);
if (boss instanceOf Employee e) ...; //boss当然是Employee对象
```

用instanceOf模式引入的变量可以立即在同一个表达式中使用：

```Java
Employee e;
if (e instanceOf Manager m && m.getBonus() > 2000) ...;
//只有当&&表达式的左侧为true时才计算其右侧
```

### 10) 受保护访问

一般将类的字段标记private、方法标记public，不过有时需要==子类能访问父类的字段、父类的方法只能由子类调用==。

**关键字protected**：限定字段/方法只能由同一个包中的子类访问/调用。

访问修饰符：

- private：仅本类可以访问。
- public：可由外部访问。
- protected：仅==本包中的所有子类==可以访问。
- 默认（无需修饰符）：仅本包可以访问。

## 2. Object

Object类是Java中所有类的祖先类，每个类都扩展自Object。

### 1) Object类变量

Object类型的变量可以引用任何类型的对象：

```Java
Object obj = new Employee(...);
```

Object类型的变量只能作为一个泛型容器，对其中的内容进行具体操作前，需要==强制转换为对象的实际类型==：

```Java
Employee e = (Employee) obj;
```

只有基本类型（数值、字符和布尔值）不是对象，所有数组类型（无论对象数组还是基本类型数组）都扩展自Object：

```Java
Employee[] staff = new Employee[10];
obj = staff; //OK
obj = new int[10]; //OK
```

### 2) equals

**方法equals**：检查两个对象是否相等（检查两个对象引用是否相同）。

> P175-176

### 3) 相等测试与继承

> P176-178

### 4) hashCode

**散列码**(hash code)：由对象导出的一个整型值，没有规律，不同对象的散列码不同。

```Java
/*String类的散列码算法*/
int hash = 0;
for (int i = 0; i < length(); i++)
	hash = 31 * hash + charAt(i);
```

**方法hashCode**定义在Object中，因此每个对象都有一个默认的散列码，其值==由对象的存储地址导出==。

```Java
/*hashCode的使用*/
var s = "OK";
var sb = new StringBuilder(s);
var t = new String("OK");
var tb = new StringBuilder(t);
System.out.println(s.hashCode()); //2556
System.out.println(sb.hashCode()); //20526976
System.out.println(t.hashCode()); //2556
System.out.println(tb.hashCode()); //20527144
```

`s`与`t`的散列码相同，因为==字符串的散列码由内容导出==；而`sb`与`tb`的散列码不同，因为StringBuilder类没有重写hashCode，将调用Object.hashCode，返回由对象的存储地址导出的散列码。

重写hashCode时，应合理组合实例字段的散列码，==使不同对象的散列码尽量分散开==。例如，对于日期，算法`7 * year + 11 * month + 13 * day`将产生很多冲突，`31 * 12 * year + 31 * month + day`则较优。

```Java
/*Employee.hashCode的定义*/
public int hashCode()
{
	return 7 * name.hashCode + 11 * Double.valueOf(salary).hashCode + 13 * hireDay.hashCode();
}
```

改进...

- 使用null安全的方法Objects.hashCode（参数为null时返回0）。
- 使用静态方法Double.hashCode避免构造Double对象。

```Java
/*改进Employee.hashCode*/
public int hashCode()
{
	return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay);
}
```

**方法Objects.hash**：提供所有参与生成散列码的值作为参数，它将对各个参数调用Objects.hashCode，再自动组合。

```Java
/*用Objects.hash实现Employee.hashCode*/
public int hashCode()
{
	return Objects.hash(name, salary, hireDay);
}
```

equals与hashCode的定义必须相容，如果`x.equals(y)`返回`true`，那么`x.hashCode()`与`y.hashCode()`的返回值必须相同。

**方法Arrays.hashCode**：返回数组类型字段的散列码。

记录类型自动提供hashCode。

### 5) toString

**方法toString**：返回一个字符串，表示对象的值。

```Java
/*toString返回字符串的习惯格式*/
"*ClassName[*fields]"
```

```Java
/*Employee.toString的定义*/
public String toString()
{
	return "Employee[name=" + name + ... + "]";
}
```

改进，调用`getClass().getName()`获取类名。

```Java
/*改进Employee.toString*/
public String toString()
{
	return getClass().getName() + "[name=" + name + ... + "]";
}
```

如果父类toString有调用`getClass().getName()`，那么子类只需调用`super.toString()`。

```Java
/*调用父类toString*/
public String toString()
{
	return super.toString() + "[name=" + name + ... + "]";
}
```

自动对对象`x`调用`x.toString()`：

- `x`与字符串通过字符串连接符(+)连接时（因此`x.toString()`可写作`""+x`，不同在于，当`x`为基本类型时，只有后者可以编译）。
- 调用`System.out.println(x)`时。

如果调用`x.toString()`时，其所属类没有重写toString，将调用Object.toString，返回所属类类名与散列码的字符串。

```Java
int[] n = { 2, 3, 5, 7, 11, 13 };
String s = "" + n;
```

`s`为"\[I@1a46e30"，"\[I"表示这是一个int类型数组。这不是对数组内元素的描述，要获得正确描述，应调用**方法Arrays.toString**：

```Java
String s = Arrays.toString(n); //"[2, 3, 5, 7, 11, 13]"
```

## 3. ArrayList

一些语言要求在编译时确定数组大小，Java则允许在运行时确定。

**ArrayList类**：一个有**类型参数**(type parameter)的**泛型类**(generic class)，类似于数组，但可以容纳任意类型的对象，并且支持创建后动态修改大小。

### 1) 声明ArrayList

```Java
/*ArrayList的声明格式*/
ArrayList<*element_type> *variable = new ArrayList<*element_type>();

//最好使用var

var variable = new ArrayList<*element_type>();

//不使用var时可以省略尖括号中的元素类型参数

ArrayList<*element_type> *variable = new ArrayList<>();
```

这称为菱形语法（因为一对尖括号(\<>)形似菱形），它结合new使用。如果赋值给变量/传递给方法/从方法返回，编译器将该变量/参数/方法的泛型类型放在"\<>"中：

```Java
ArrayList<Employee> staff = new ArrayList<>();
```

此处，`new ArrayList<>()`将赋值给类型为`ArrayList<Employee>`的`staff`，泛型类型为Employee。

**方法add**：添加元素。

```Java
staff.add(new Employee(...));
```

当ArrayList的空间耗尽后，再次调用方法add时，将自动创建一个更大的ArrayList，并将所有元素拷贝到新数组。

自动创建新ArrayList并拷贝元素的开销较大，如果预先知道数组可能存储的元素数量，可以在填充数组前调用**方法ensureCapacity**指定初始容量，或在构造时指定。

```Java
/*确定数组列表的大小*/
staff.ensureCapacity(100);

//或者

ArrayList<Employee> staff = new ArrayList<>(100);
```

现在，前100次add调用不会引起自动创建新ArrayList并拷贝元素的开销

**方法size**：返回==实际包含的元素数量==，调用`al.size()`等同于数组的`a.length()`。

**方法trimToSize**：如果能确定数组列表的大小不会再改变，调用`al.trimToSize()`将内存块的大小调整为存储当前实际元素所需的空间。

### 2) 访问数组列表元素

**方法set**：修改已有元素，调用`al.set(i, harry)`修改第i个元素为`harry`，等同于数组的`a[i] = harry`。

只有当`al`的==大小大于i时才可以调用==`al.set(i, *object)`，反例：

```Java
var staff = new ArrayList<Employee>(100);
staff.set(0, "harry"); //此时第0个元素还不存在
```

==set只是修改已有元素==，要使用==add添加新元素==（与数组不同，数组在声明后可直接赋值，而ArrayList需要先添加元素）。

**方法get**：获取元素，调用`al.get(i)`获取第i个元素，等同于数组的`a[i]`。

> P190-191

### 3) 类型化与原始数组列表的兼容性

> P192

## 4. 对象包装器与自动装箱

所有基本类型都有与之对应的Final类（例如int对应Integer类），这些类称为**包装器**(wrapper)，名称分别为Integer，Long，Float，Double，Short，Byte，Character，Boolean。

包装器类对象不可变，一经构造，==包装在其中的值无法修改==。

比较两个包装器对象需用equals。

```Java
/*创建一个元素类型为int的ArrayList*/
var intAl = new ArrayList<int>(); //非法

//需要使用Integer包装器类

var intAl = new ArrayList<Integer>();
```

**自动装箱**：自动转换特性，调用`al.add(3)`将自动转换为`al.add(Integer.valueOf(3))`。

**自动拆箱**：与自动装箱过程相反的特性，调用`al.get(i)`将自动转换为`al.get(i).intValue();`。

如果在同一个表达式中混用Integer与Double类型，Integer值将拆箱为int，提升为double后再装箱为Double。

包装器对象引用可为null，所以自动装箱可能抛出NullPointerException。

**方法parseInt**：将数字字符串转换为数值，调用`Integer.parseInt(s)`将字符串`s`转换为int。实际上，parseInt为static，与Integer对象没有关系。

## 5. 参数个数可变的方法

```Java
/*printf的定义*/
public class PrintStream
{
	public PrintStream printf(String fmt, Object... args)
	{
		return format(fmt, args);
	}
}
```

printf接收两个参数，一个字符串与一个Object\[]数组，省略号(...)是代码的一部分，表示该Object数组可以==容纳任意数量的参数==。

可以自定义参数个数可变的方法：

```Java
/*计算若干数值中最大值的方法max*/
public static double max(double... values)
{
	double largest = Double.NEGATIVE_INFINITY;
	for (double v : values) if (v > largest) largest = v;
	return largest;
}
```

调用`double m = max(3.1, 40.4, -5)`时，max将接收数组`double[] { 3.1, 40.4, -5 }`。

对一个方法，只要最后一个参数为数组，就可以改写为参数个数可变的方法。甚至可以将main声明为`public static void main(String... args)`。

## 6. 抽象类

考虑扩展Employee层次结构，新增Student类，员工与学生都是人，他们有一些共同的属性（如姓名），通过引入公共父类Person，可以将getName等通用方法放在继承层次结构中的更高层。

增加方法getDescription，返回对一个人的简短描述。对于两个子类来说这很容易，但Person类除了姓名外对此人一无所知，可以返回一个空串，不过更好的做法是使用**关键字abstract**将Person.getDescription声明抽象方法。

```Java
/*abstract的使用*/
public abstract String getDescription();
```

==包含抽象方法的类必须声明为抽象类==。

```Java
/*将Person声明为abstract*/
public abstract class Person
{
	...
	public abstract String getDescription();
}
```

抽象方法相当于要在子类中实现的具体方法的占位符，除抽象方法外，==抽象类也可以有字段与具体方法==。

扩展一个抽象类时可以...

- 在子类中保持抽象父类中的至少一个抽象方法仍未定义，子类仍需声明为abstract。
- 在子类中实现抽象父类的全部抽象方法，子类无需声明为abstract（不过也可以这样做）。

==抽象类不能实例化==，只能创建其对象变量，且该变量==只能引用其非抽象子类的对象==：

```Java
/*抽象类型的变量*/
Person p = new Student(...)
```

```Java
/*抽象类的使用*/
var people = new Person[2];
people[0] = new Employee(...);
people[1] = new Student(...);

for (Person p : people)
	System.out.println(p.getName() + ", " + p.getDescription);
```

调用`p.getDescription()`将分别调用Employee.getDescription与Student.getDescription，`p`永远不会引用一个Person对象，所以==永远不会调用未经实现的Person.getDescription==。

如果省略Person.getDescription的声明而只在其子类中定义getDescription，那么将不能调用`p.getDescription()`，这就是抽象方法存在的意义。

## 7. 枚举类

```Java
/*一个枚举类*/
public enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE };
```

此处定义了一个枚举类，`SMALL`至`EXTRA_LARGE`均为其实例。

枚举类不可能构造新的对象，因此在比较对象时可以用相等运算符(\==)，无需equals。

枚举类可以有字段、构造器与方法。

```Java
/*为Size增加字段、构造器与方法*/
public enum Size
{
	SMALL("S"), MEDIUM("M"), LARGE("L"), EXTRA_LARGE("XL");
	private String abbreviation;
	Size(String abbreviation) { this.abbreviation = abbreviation; }
	public String getAbbreviation() { return abbreviation; }
}
```

枚举类的==构造器只能且自动声明为私有==。

所有枚举类都是抽象类Enum的子类，它们继承了很多方法：

- **方法toString**：返回枚举常量名，调用`Size.SMALL.toString()`将返回字符串"SMALL"。
- **方法valueOf**：toString的逆方法，调用`Size s = Enum.valueOf(Size.class, "SMALL")`将`s`赋值为`Size.SMALL`。
- **方法values**：返回一个包含全部枚举值的数组，调用`Size[] values = Size.values()`将`values`赋值为`{ Size.SMALL, Size.MEDIUM, Size.LARGE, Size.EXTRA_LARGE }`。
- **方法ordinal**：返回一个枚举常量在枚举类声明中的位置，调用`Size.MEDIUM.ordinal()`将返回1。

## 8. 密封类

除非将类声明为final，否则它可以被继承，如果要对自定义类（例如自己的JSON库）拥有更多控制权，可以使用**密封类**控制其他类对它的继承权限，**关键字sealed**、**permits**。

```Java
/*密封类的声明*/
public abstract sealed class JSONValue permits JSONArray, JSONNumber, JSONString, JSONBoolean, JSONObject, JSONNull
{
	...
}
```

==密封类允许的子类必须是可访问的==，不能是嵌套在另一个类中的私有类，也不能是位于另一个包中的包可见的类。

密封类的声明可以不含permits子句，此时，其所有直接子类都必须与其在同一个文件中声明，而一个文件最多有一个public类，所以其所有子类只能为private。

使用密封类的优点为编译时检查，考虑JSONValue的方法type（使用了Java 17中的预览特性，带模式匹配的switch表达式）：

```Java
public String type()
{
	return switch (this)
	{
		case JSONArray j -> "array";
		case JSONNumber j -> "number";
		case JSONString j -> "string";
		case JSONBoolean j -> "boolean";
		case JSONObject j -> "object";
		case JSONNull j -> "null";
		//无需default
	}
}
```

编译器可以检查到此处无需default，因为JSONValue的所有子类都出现在case中。

密封类的==子类必须声明为sealed、final，或者non-sealed==（允许继续派生子类）。

	关键字non-sealed是第一个带连字符的关键字，这可能是未来趋势。

## 9. 反射

反射库提供了一个丰富且精巧的工具集，可以用以编写动态操纵Java代码的程序，例如用户界面生成器、对象关系映射器以及很多其他需要动态查询类能力的开发工具。

能够分析类能力的程序称为可反射。可以用以：

- 在运行时分析类的能力。
- 在运行时检查对象，例如，编写一个适用于所有类的toString方法。
- 实现泛型数组操作代码。
- 利用Method对象。

> P209-230

## 10. 继承的设计技巧

以下是使用继承时的一些技巧。

- 将公共操作和字段放在父类中。
- 不要使用受保护的字段。
- 使用继承实现“is-a”关系。
- 除非所有继承的方法都有意义，否则不要使用继承。
- 覆盖方法时，不要改变预期的行为。
- 使用多态，而不要使用类型信息。
- 不要滥用反射。