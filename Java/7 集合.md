## 1. Java集合框架

### 1) 集合接口与实现分离

下面用**队列**(queue)说明集合接口与实现分离。

Queue接口指出可以在队尾添加元素、在队头删除元素（先进先出），并且可以查找队列中元素的序号。

```Java
/*Queue的简单形式*/
public interface Queue<E>
{
	void add(E element);
	E remove();
	int size();
}
```

Queue并未说明队列的实现方式，通常有循环数组与链表两种实现方式，它们都可以用一个实现了Queue的类表示。

```Java
/*用循环数组实现队列*/
public class CircularArrayQueue<E> implements Queue<E>
{
	private int head;
	private int tail;
	
	CircularArrayQueue(int capacity) { ... }
	public void add(E element) { ... }
	public E remove() { ... }
	public int size() { ... }
	private E[] elements;
}
```

```Java
/*用链表实现队列*/
public class LinkedListQueue<E> implements Queue<E>
{
	private Link head;
	private Link tail;
	
	LinkedListQueue() { ... }
	public void add(E element) { ... }
	public E remove() { ... }
	public int size() { ... }
}
```

某种程度上，循环数组比链表更高效，不过它是一个**有界**(bounded)集合，容量有限。

```Java
/*CircularArrayQueue的使用*/
Queue<Customer> expressLane = new CircularArrayQueue<>(100);
expressLane.add(new Customer("Harry"));
```

### 2) Collection接口

Java类库中，集合类的基本接口为Collection接口。

```Java
/*Collection的定义*/
public interface Collection<E>
{
	boolean add(E element);
	Iterator<E> iterator();
	...
}
```

**方法add**：向集合中添加元素，如果添加元素确实改变了集合将返回true，否则返回false，例如试图向**集**(set)中添加一个已存在的对象时将返回false，因为集中不允许有重复对象。

**方法iterator**：返回一个实现了**Iterator接口**的对象（迭代器），用于依次访问集合中的元素。

### 3) 迭代器

```Java
/*Iterator的定义*/
public interface Iterator<E>
{
	E next();
	boolean hasNext();
	void remove();
	default void forEachRemaining(Consumer<? super E> action);
}
```

**方法next**：访问迭代器的下一个位置上的元素，到达末尾时再次调用将抛出NoSuchElementException，因此==每次调用前需调用**方法hasNext**检查==。

要访问集合中的元素，可以构建一个迭代器`iter`，当hasNext返回true时反复调用`iter.next()`。

```Java
/*迭代器的构建与使用*/
Collection<String> c = ...;
Iterator<String> iter = c.iterator();
while (iter.hasNext())
{
	String element = iter.next();
	...
}
```

可以将while改为for-each：

```Java
for (String element : c) { ... }
```

编译器自动将for-each转换为一个带迭代器的循环。

for-each可以处理任何实现了**Iterable接口**的类对象。

```Java
/*Iterable的定义*/
public interface Iterable<E>
{
	Iterator<E> iterator();
}
```

Collection扩展自Iterable，因此==for-each可以用于标准库的所有集合对象==。

可以将循环改写为调用**方法forEachRemaining**并提供一个lambda。

```Java
/*forEachRemaining的使用*/
iterator.forEachRemaining(element -> ... )
```

**方法remove**：删除==上次访问==的元素，remove需在调用next之后调用，==连续调用remove非法==。

```Java
/*不能连续调用remove*/
it.remove();
it.remove(); //抛出IllegalStateException
```

### 4) 泛型实用方法

Collection与Iterator都为泛型接口，可以自己编写处理集合的方法，例如，检测某个集合中是否有指定元素：

```Java
public static <E> boolean contains(Collection<E> c, Object obj)
{
	for (E element : c)
		if (element.equals(obj))
			return true;
	return false;
}
```

Collection声明了很多抽象方法，要求每个实现Colletion的类都实现全部方法将非常烦琐，所以Java类库中有一个**AbstractCollection类**，其中==保持size与iterator为抽象==，其他方法则已有默认实现，具体集合类可以继承AbstractCollection。

## 2. 集合框架中的接口

集合的两个基本接口为Collection、Map。

List是一个有序集合，元素将添加到容器中的特定位置，可以采用两种方式访问元素，迭代器或整数索引，前者只能按顺序访问元素，后者则可以按任意顺序。

```Java
/*List接口中的随机访问方法*/
void add(int index, E element)
void remove(int index)
E get(int index)
E set(int index, E element)
```

**ListIterator接口**是Iterator的子接口，其中的add用于在==迭代器位置之前==增加元素。

**Set接口**等同于Collection，不过其方法的行为更加严谨，例如，==add不允许增加重复元素==。

**SortedSet接口**与**SortedMap接口**提供用于排序的Comparator对象。

**NavigableSet接口**与**NavigableMap接口**包含额外的用于搜索和遍历有序集合和映射的方法，它们由TreeSet类与TreeMap类实现。

## 3. 具体集合

> Java类库中的集合及其用途见P386表9-1

除了\*Map类实现Map外，其他类都实现Collection。

|结构|有序|修改开销|访问速度|
|:-:|:-:|:-:|:-:|
|链表|是|小|慢|
|数组列表||||
|散列集|否|小|快|
|树集|是|中|
|队列|是|||

### 1) 链表 LinkedList

数组的缺陷在于每次删除元素时都要平移部分元素，开销很大，而**链表**(linked list)能解决此问题。

数组在连续的存储位置上存放对象引用，而链表则将各个对象存放在单独的**链接**(link)中，且每个链接中存放序列中下一个链接的引用。链表是一个有序集合，每个对象的位置很重要。Java中链表是双向链接的，即链接还存有上一个链接的引用。

**方法LinkedList.add**：将对象添加到链表尾部。

从链表中删除元素的开销很小，只需更改其前后邻的链接引用即可。

```Java
/*链表的构建与使用*/
var staff = new LinkedList<String>();
staff.add("Amy");
staff.add("Bob");
staff.add("Carl");
Iterator<String> iter = staff.iterator();
String first = iter.next();
String second = iter.next();
iter.remove(); //删除上次访问的元素，也就是第二个元素
```

==只能对有序集合使用迭代器添加元素==，例如，**集**(set)是无序的，因此add没有在Iterator中声明，而是在其子接口ListIterator中声明。

```Java
/*ListIterator的定义*/
interface ListIterator<E> extends Iterator<E>
{
	void add(E element);
	E previous();
	boolean hasPrevious();
	...
}
```

与Collection.add不同，ListIterator.add假定操作总将改变链表，因此不返回boolean值。

与next相同，**方法previous**将迭代器向前移动，并返回越过的对象。

add添加元素的位置只与迭代器的位置有关（在迭代器的当前位置）；而remove将删除上一个访问的元素，所以其删除的元素还与迭代器的状态有关：

- 在调用next后调用remove，将删除迭代器当前位置左侧的元素。
- 在调用previous后调用remove，将删除迭代器当前位置右侧的元素。

**方法set**对元素的选择规则与remove相同，不过它将选中元素替换为指定的新值。

如果有两个迭代器，当其中一个在遍历集合时、另一个在修改集合，那么很可能出现混乱。

```Java
/*两个迭代器对集合同时访问与修改*/
List<String> list = ...;
ListIterator<String> iter1 = list.listIterator();
ListIterator<String> iter2 = list.listIterator();
iter1.next();
iter1.remove();
iter2.next(); //抛出ConcurrentModificationException
```

为了避免此异常，可以为一个集合关联多个只读迭代器，或者仅为其关联一个读写迭代器。

迭代器检测异常的原理是，每个迭代器都有一个自己的修改计数器，集合有一个总的修改计数器，如果某个迭代器的修改次数与集合的总修改次数不同，就会抛出异常。例外是，此计数器只计入结构性修改（add与remove），而set不被视为结构性修改，所以==所有迭代器都可以调用set==来修改集合的内容，许多算法都依赖于此例外。

Collection还声明了很多其他方法，它们大部分由LinkedList的父类AbstractCollection实现，例如：

- **方法toString**对所有元素调用toString并生成一个长字符串。
- **方法contains**检测链表中是否存在指定元素，例如，如果`list`中存在元素"Harry"，调用`list.contains("Harry")`将返回true。

**方法nextIndex**：返回下一次调用next时返回的元素的索引。

**方法previousIndex**：返回下一次调用previous时返回的元素的索引。

访问链表的第n个元素时，只能从头开始、越过n-1个元素，没有捷径可走，效率非常低，==如需按索引访问元素，通常不选择链表==。

### 2) 数组列表 ArrayList

> P396

### 3) 散列集 HashSet

数组与链表中的元素有序排列，如需查找某个特定元素，而其位置未知，则需遍历所有元素，时间开销较大。如果不在意元素的顺序，还有几种数据结构按照对自己最方便的顺序组织元素，它们不允许指定元素位置，但是查找元素耗时很短。

**散列表**(hash table)为每个对象计算其散列值，它==实现为链表数组==，每个链接称为**桶**(bucket)。

查找某个元素时，计算其散列值，对桶的总数取余，即为该元素的桶索引（例如，某对象散列值为76268，共有128个桶，那么该对象保存在76268%128=108号桶中）。

添加元素时，目标桶可能已经存在元素，称为**散列冲突**(hash collision)，此时将新对象与原有对象进行比较（设计hashCode时应选择合理的算法使不同对象的散列码尽可能分散）。

如果大致知道元素总数，可以设置桶数，通常设置为==预计元素总数的75%~150%==。标准类库中的实现限定桶数为2的幂，==默认为16==，提供的值将被调整为2的下一个幂。

散列表爆满时，需要**再散列**(rehash)，原理是创建一个桶数为原先2倍的新链表，转移元素后删除旧链表。**装填因子**(load factor)决定何时进行再散列，例如，如果装填因子为0.75（默认值），当链表填充75%以上时将自动进行再散列。

散列表可以实现很多重要数据结构，其中一个为集，它是没有重复的元素集合，其add在添加元素前先进行搜索，不存在时才会添加。

```Java
/*用HashSet统计文件中不同单词的个数*/
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

public class SetTest
{
	public static void main(String[] args)
	{
		var words = new HashSet<String>();
		long totalTime = 0;
		Path path = Paths.get("D:\\test.txt");
		
		try (var in = new Scanner(path))
		{
			while (in.hasNext())
			{
				String word = in.next();
				long callTime = System.currentTimeMillis();
				words.add(word);
				callTime = System.currentTimeMillis() - callTime;
				totalTime += callTime;
			}
		}
		catch (IOException e)
		{
			throw new RuntimeException(e);
		}
		
		Iterator<String> iter = words.iterator();
		for (int i = 1; i <= 20 && iter.hasNext(); i++)
			System.out.println(iter.next());
		System.out.println("...");
		System.out.println(words.size() + " distinct words. " + totalTime + " milliseconds.");
	}
}
```

### 4) 树集 TreeSet

**树集**(TreeSet)类似于散列集，不过它是一个有序集合，==可以按任意顺序将元素插入集合==，==遍历时，值将按照自动排列后的顺序出现==。

```Java
/*TreeSet的使用*/
var sorter = new TreeSet<String>();
sorter.add("Carl");
sorter.add("Amy");
sorter.add("Bob");
for (String s : sorter) System.out.println(s);
//"Amy"
//"Bob"
//"Carl"
```

排序是用一个树数据结构实现的（当前实现使用**红黑树**(red-black tree)）。将元素添加到树中比添加到散列表中慢，不过与检查数组或链表中的重复元素相比还是快很多，其时间复杂度为$O(\log_2 n)$，例如，对包含1000个元素的树，添加元素前平均需要比较10次。

要使用树集，必须能够比较元素，它们必须实现Comparable，或者必须在构造集时提供一个Comparator。

HashSet与TreeSet的选择取决于要收集的数据，如果不需要数据有序，就==没有必要付出排序的开销==，更重要的是，对于某些数据，对其进行排序比给出一个散列算法更困难，后者只需将数据适当地打乱存放，而==前者必须精确地区分各个对象==。

```Java
/*TreeSet的使用*/
import java.util.*;

public class TreeSetTest
{
	public static void main(String[] args)
	{
		var parts = new TreeSet<Item>();
		parts.add(new Item("Toaster", 1234));
		parts.add(new Item("Widget", 4562));
		parts.add(new Item("Modem", 9912));
		System.out.println(parts);
		
		var sortByDescription = new TreeSet<Item>(Comparator.comparing(Item::getDescription));
		
		sortByDescription.addAll(parts);
		System.out.println(sortByDescription);
	}
}

class Item implements Comparable<Item>
{
	private String description;
	private int partNumber;
	
	public Item(String aDescription, int aPartNumber)
	{
		description = aDescription;
		partNumber = aPartNumber;
	}
	
	public String getDescription()
	{
		return description;
	}
	
	public String toString()
	{
		return "[description=" + description + ", partNumber=" + partNumber + "]";
	}
	
	public boolean equals(Object otherObject)
	{
		if (this == otherObject) return true;
		if (otherObject == null) return false;
		if (getClass() != otherObject.getClass()) return false;
		var other = (Item) otherObject;
		return Objects.equals(description, other.description) && partNumber == other.partNumber;
	}
	
	public int hashCode()
	{
		return Objects.hash(description, partNumber);
	}
	
	public int compareTo(Item other)
	{
		int diff = Integer.compare(partNumber, other.partNumber);
		return diff != 0 ? diff : description.compareTo(other.description);
	}
}
```

### 5) 队列与双端队列 Queue Deque

**队列**(queue)可以在队尾添加元素、在队头删除元素，**双端队列**(deque, double-ended queue)在队头与队尾都可以添加和删除元素。==队列中间不能添加元素==。

Deque接口由ArrayDeque类与LinkedList实现，它们都可以提供双端队列，其大小可以根据需要扩展，12章详细介绍。

### 6) 优先队列 PriorityQueue

**优先队列**(priority queue)中的元素可以按任意顺序插入，获取时则按一定顺序，调用remove时总会获得当前的最小元素。

优先队列并没有对元素排序，而是使用了**堆**(heap)数据结构，后者是一个自组织的二叉树，其add与remove操作会将最小的元素移动至根，而不必花时间排序。

类似于TreeSet，PriorityQueue的元素也需要实现Comparable，或者在构造时提供一个Comparator。

PriorityQueue的典型用法为任务调度，每个任务有一个优先级，任务以随机顺序添加到队列中，每次启动一个新任务时将从中==删除优先级最高的任务==（习惯上将1作为最高优先级）。

```Java
/*PriorityQueue的使用*/
import java.util.*;
import java.time.*;

public class PriorityQueueTest
{
	public static void main(String[] args)
	{
		var pq = new PriorityQueue<LocalDate>();
		pq.add(LocalDate.of(1906, 12, 9));
		pq.add(LocalDate.of(1815, 12, 10));
		pq.add(LocalDate.of(1903, 12, 3));
		pq.add(LocalDate.of(1910, 6, 22));
		
		System.out.println("Iterating over elements...");
		for (LocalDate date : pq)
			System.out.println(date);
		System.out.println("Removing elements...");
		while (!pq.isEmpty())
			System.out.println(pq.remove());
	}
}
```

```Text
/*输出*/
Iterating over elements...
1815-12-10
1906-12-09
1903-12-03
1910-06-22
Removing elements...
1815-12-10
1903-12-03
1906-12-09
1910-06-22
```

## 4. 映射

集可以快速查找元素，但要求准确对应，有时查找元素时并不知道其准确副本，只知道与其关联的关键信息，**映射**(map)数据结构就是为此设计的。

映射用来存放键/值对，==提供键可以查找值==，例如，存储一个员工记录表，键为员工ID，值为Employee对象。

### 1) 基本映射操作

Java类库为映射提供的两个通用实现为**HashMap**与**TreeMap**，它们都实现了Map接口。

HashMap对键进行散列，散列函数与比较函数==只能应用于键==，不能对值进行散列或比较。

TreeMap根据键的顺序将它们组织为一个搜索树。

类似于HashSet与TreeSet，HashMap与TreeMap的选择取决于要收集的数据，如果不需要数据有序，可以优先选择HashMap。

```Java
/*HashMap的使用*/
var staff = new HashMap<String, Employee>();
var harry = new Employee("Harry Hacker");
staff.put("987-98-9996", harry);

var id = "987-98-9996";
Employee e = staff.get(id);
```

==一个键只能对应一个值==，如果对同一个键两次调用**方法put**，新值将覆盖旧值。

如果映射中没有存储与指定键对应的值，调用**方法get**将返回null，这可能不太方便，对于此情况可以调用**方法getOrDefault**，指定一个默认返回值。

```Java
/*getOrDefault的使用*/
Employee e = staff.getOrDefault(id, 0);
```

**方法remove**：从映射中删除对应于指定键的值。

**方法size**：返回总值数。

**方法forEach**：迭代处理映射中的键与值，可以提供一个接受键与值的lambda，映射中的每一项将依次调用此lambda。

```Java
/*forEach的使用*/
staff.forEach((k, v) -> System.out.println("key=" + k + ", value=" + v));
```

```Java
/*HashMap的使用*/
import java.util.*;

public class MapTest
{
	public static void main(String[] args)
	{
		var staff = new HashMap<String, Employee>();
		staff.put("144-25-5464", new Employee("Amy Lee"));
		staff.put("567-24-2546", new Employee("Harry Hacker"));
		staff.put("157-62-7935", new Employee("Gary Cooper"));
		staff.put("456-62-5527", new Employee("Francesca Cruz"));
		
		System.out.println(staff);
		
		staff.remove("567-24-2546");
		
		staff.put("456-62-5527", new Employee("Francesca Cruz"));
		
		System.out.println(staff.get("157-62-7935"));
		
		staff.forEach((k, v) -> System.out.println("key=" + k + ", value=" + v));
	}
}
```

### 2) 更新映射条目

例如，使用映射统计一个单词在文本中出现的次数，读取到指定单词时计数器加1：

```Java
counts.put(word, counts.get(word) + 1);
```

不过，第一次读取到`word`时调用`get(word)`将返回null，抛出NullPointerException。

一种简单的补救措施是调用getOrDefault：

```Java
counts.put(word, counts.getOrDefault(word, 0) + 1);
```

另一种方式是调用**方法putIfAbsent**，只有当键原先不存在或映射到null时才放入一个值：

```Java
counts.putIfAbsent(word, 0);
counts.put(word, counts.get(word) + 1);
```

**方法merge**可以简化此操作，如果键原先不存在，此调用：

```Java
counts.merge(word, 1, Integer::sum);
```

将`word`与1关联，否则调用`Integer::sum`将原值与指定值`1`相加作为新值。

### 3) 映射视图

映射的**视图**(view)是实现了Collection或其子接口的对象，有三种视图，键集、值集、键/值对集，它们分别由以下方法返回：

```Java
Set<K> keySet()
Collection<V> values()
Set<Map.Entry<K, V>> entrySet()
```

keySet是实现了Set的另外一个类的对象。

如果需要同时查看键与值，可以通过枚举映射条目避免查找值：

```Java
for (Map.Entry<String, Employee> entry : staff.entrySet())
{
	String k = entry.getKey();
	Employee v = entry.getValue();
	...
}
```

通过var可以避免Map.Entry：

```Java
for (var entry : staff.entrySet())
```

或者直接使用forEach：

```Java
map.forEach((k, v) ->
	{
		...
	});
```

### 4) 弱散列映射 WeakHashMap

> P411

### 5) 链接散列集与映射 

LinkedHashSet与LinkedHashMap将记住插入元素的顺序，避免看上去随机的顺序。

```Java
/*LinkedHashMap的使用*/
var staff = new LinkedHashMap<String, Employee>();
staff.put("001", new Employee(...));
...
var iterByKeySet = staff.keySet().iterator(); //按顺序遍历键的迭代器
var iterByValues = staff.values().iterator(); //按顺序遍历值的迭代器
```

迭代时，除了按插入顺序，还可以按访问顺序，每次调用get或put时，受影响的条目将从当前位置移至条目链表的末尾（只影响条目链表中的位置，而不影响散列表的桶），如下构造：

```Java
LinkedHashMap<K, V>(*initialCapacity, *loadFactor, true);
```

实现“最近最常使用”时（例如将最近访问频率高的元素放在内存中、访问频率低的元素由数据库读取），访问顺序很重要，例如，在映射表满时删除前几个元素，也即最近最少使用的元素。

要自动完成此过程，可以构造LinkedHashMap的一个子类，覆盖方法removeEldestEntry：

```Java
protected boolean removeEldestEntry(Map.Entry<K, V> eldest)
```

当其返回true时，添加新元素将删除`eldest`。

```Java
/*removeEldestEntry的使用*/
var cache = new LinkedHashMap<K, V>(128, 0.75F, true)
	{
		protected boolean removeEldestEntry(Map.Entry<K, V> eldest)
		{
			return size() > 100; //最多允许存放100个元素
		}
	}
```

### 6) 枚举集与映射 EnumSet EnumMap

EnumSet的元素为枚举类型，由于枚举类型的实例数量有限，EnumSet在内部实现为一个位序列，如果对应的值包含在其中，该位置值为1。

```Java
enum Weekday { ... };
EnumSet<Weekday> always = EnumSet.allOf(Weekday.class);
EnumSet<Weekday> never = EnumSet.noneOf(Weekday.class);
EnumSet<Weekday> workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);
EnumSet<Weekday> mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);
```

修改时，使用Set接口的常用方法。

EnumMap的键为枚举类型，可以简单高效地实现为一个值数组。

```Java
var personInCharge = new EnumMap<Weekday, Employee>(Weekday.class);
```

### 7) 标识散列映射 IdentityHashMap

IdentityHashMap中，键的散列值不由hashCode计算，而由方法System.identityHashCode计算，Object.hashCode也调用了后者。

比较对象时，IdentityHashMap使用\==而非equals，也就是说，不同键对象即使内容相同，也被视为不同对象。

实现对象遍历算法时，如需跟踪已经遍历过的对象，可以使用IdentityHashMap。

## 5. 副本与视图

通过视图(view)可以得到其他实现了Collection或Map的类对象，上文的keySet返回一个实现了Set的类对象，后者的方法可以操纵原映射，这种集合就是视图。

### 1) 小集合

```Java
List<String> names = List.of("Peter", "Paul", "Mary");
Set<Integer> numbers = Set.of(2, 3, 5);
Map<String, Integer> scores = Map.of("Peter", 2, "Paul", 3, "Mary", 5);
```

List与Set接口有11个方法of，分别接受0至10个参数，另有一个参数个数可变的of。

Map接口无法提供参数个数可变的方法（因为参数需交替为键/值），它有一个静态方法ofEntries，接收任意数量的Map.Entry<K, V>对象。

```Java
import static java.util.Map.*;

Map<String, Integer> scores = ofEntries(
	entry("Peter", 2),
	entry("Paul", 3),
	entry("Mary", 5));
```

这些集合对象是不可修改的(unmodifiable)，尝试修改将产生UnsupportedOperationException。

如需一个可修改的集合，可以将不可修改的集合传递给构造器：

```Java
var names = new ArrayList<>(List.of("Peter", "Paul", "Mary"));
```

调用`Collections.nCopies(*n, *anObject)`给人一种错觉，好像有`n`个元素、每个元素是一个`anObject`，但实际上，该对象只存储一次。

```Java
List<String> settings = Collections.nCopies(100, "DEFAULT");
```

将创建一个包含100个字符串"DEFAULT"的List，不过该对象只存储一次，存储开销很小。

### 2) 不可修改的副本和视图

方法copyOf：创建一个集合的不可修改副本(unmodifiable copy)。

```Java
ArrayList<String> names = ...;
Set<String> nameSet = Set.copyOf(names);
List<String> nameList = List.copyOf(names);
```

修改原集合时，其副本不受影响。

如果原集合不可修改，且副本与之类型相同，则会直接返回原集合。

Collections类还有一些方法用于生成集合的不可修改的视图(unmodifiable view)：

```Java
Collections.unmodifiableCollection
Collections.unmodifiableList
Collections.unmodifiableSet
Collections.unmodifiableSortedSet
Collections.unmodifiableNavigableSet
Collections.unmodifiableMap
Collections.unmodifiableSortedMap
Collections.unmodifiableNavigableMap
```

与副本不同，原集合变化时，视图将同步变化。

方法lookAt：读取集合的内容，但不修改。

```Java
var staff = new LinkedList<String>();
...
lookAt(Collections.unmodifiableList(staff));
```

可以通过lookAt调用List的所有方法，而不只是访问器，但是所有的更改器方法已经重定义为抛出UnsupportedOperationException。

由于视图只是包装了接口而不是具体的集合对象，所以只能访问接口中定义的方法，例如，LinkedList有一些便利方法如addFirst与addLast，但它们没有在List接口中定义，不能通过不可修改的视图访问。

### 3) 子范围

可以为很多集合建立子范围(subrange)视图，例如，假设有一个List为`staff`，要从中取出第10-19个元素，可以使用方法subList：

```Java
List<Employee> subStaff = staff.subList(10, 20); //左闭右开，类似于substring
```

对子范围进行的所有操作将同步到整个集合。

对于有序集与映射，可以使用顺序排序而不是元素位置建立子范围，例如，sortedSet接口声明的方法有：

```Java
SortedSet<E> subSet(E from, E to)
SortedSet<E> headSet(E to)
SortedSet<E> tailSet(E from)
```

SortedMap也有类似方法：

```Java
SortedMap<K, V> subMap(K from, K to)
SortedMap<K, V> headMap(K to)
SortedMap<K, V> tailMap(K from)
```

NavigableSet允许对子范围有更多控制，例如，指定是否包含边界：

```Java
NavigableSet<E> subSet(E from, boolean fromInclusive, E to, boolean toInclusive)
NavigableSet<E> headSet(E to, boolean toInclusive)
NavigableSet<E> tailSet(E from, boolean fromInclusive)
```

### 4) 检查型视图

将错误类型的元素混入泛型集合中的情况很常见：

```Java
var strings = new ArrayList<String>();
ArrayList rawList = strings; //WARNING，但无ERROR
rawList.add(new Date()); //一个Date类对象混入ArrayList<String>
```

检查型视图可以探测此类问题，如下定义一个安全的List：

```Java
List<String> safeStrings = Collections.checkedList(strings, String.class);
```

该视图的add将检查插入的对象是否属于给定类，如果不是，则立即抛出ClassCastException：

```Java
ArrayList rawList = safeStrings;
rawList.add(new Date()); //ClassCastException
```

### 5) 同步视图

如果从多个线程访问同一个集合，必须确保集合不会被意外破坏。类库设计者使用视图机制（而不是线程安全的集合类）来保证集合的线程安全性。

方法Collections.synchronizedMap：将任何Map转换成有同步访问方法的Map。

```Java
var map = Collections.synchronizedMap(new HashMap<String, Employee>());
```

## 6. 算法

### 1) 泛型算法的优点

泛型集合接口的优点是算法只需实现一次，例如，实现方法max返回集合中的最大元素，传统实现是循环：

```Java
if (a.length == 0) throw new NoSuchElementException();
T largest = a[0];
for (int i = 1; i < a.length; i++)
	if (largest.compareTo(a[i]) < 0)
		largest = a[i];
```

如果集合是ArrayList，还需要调用get；如果是LinkedList，还需通过迭代器调用next。为每种集合编写自己的max将极其繁琐。

此时可以使用集合接口，将max实现为能够接收任何实现了Collection的类对象。

```Java
public static <T extends Comparable> T max(Collection<T> c)
{
	if (c.isEmpty()) throw new NoSuchElementException();
	Iterator<T> iter = c.iterator();
	T largest = iter.next();
	while (iter.hasNext())
	{
		T next = iter.next();
		if (largest.compareTo(next) < 0)
			largest = next;
	}
	return largest;
}
```

现在，这个方法适用于数组、ArrayList、LinkedList等一切集合。

### 2) 排序与混排

方法Collections.sort：对实现了List的集合排序。

```Java
var staff = new LinkedList<String>();
...
Collections.sort(staff);
```

sort假定列表元素是实现了Comparable的类对象，如需使用其他依据排序，可以使用List接口的方法sort并传入一个Comparator对象：

```Java
staff.sort(Comparator.comparingDouble(Employee::getSalary));
```

如需降序排序，可以使用静态方法Collections.reverseOrder，它将返回一个Comparator，后者将返回`*b.compareTo(*a)`：

```Java
staff.sort(Comparator.reverseOrder());
```

类似地，可以指定排序依据：

```Java
staff.sort(Comparator.comparingDouble(Employee::getSalary).reversed());
```

数组的排序算法通常采用随机访问，但链表的随机访问效率很低，对链表通常使用归并排序，而Java将所有元素存入一个数组，对数组排序后将序列复制到链表。

所有接受集合参数的方法必须描述何时能够安全地将集合传递给算法（例如，显然不能将unmodifiableList传递给sort），根据文档，List必须为可修改的，而不限定可以改变大小，如果List支持...

- set，称为可修改的。
- add与remove，称为可改变大小的。

方法Collections.shuffle：随机打乱List中元素的顺序。

```Java
ArrayList<Card> cards = ...;
Collections.shuffle(cards);
```

### 3) 二分查找

方法Collections.binarySearch：对有序集合（需实现List）进行二分查找（如果传入无序集合，将返回错误答案）。

除了集合与目标元素外，如果集合没有采用Comparable.compareTo排序，还需提供一个Comparator：

```Java
*target = Collections.binarySearch(*c, *element);
*target = Collections.binarySearch(*c, *element, *comparator);
```

如果返回值非负，表示目标元素在有序状态下的索引，`c.get(i)`即为`target`；如果返回值为负，表示没有匹配到目标元素，不过可以利用返回值计算应该将目标元素插入到何处：记返回值为`i`，则目标元素应该插入`-i - 1`处。

```Java
if (i < 0)
	c.add(-i - 1, element);
```

向binarySearch传递一个LinkedList无意义，因为链表只能按顺序访问。

### 4) 简单算法

> Collections中的简单算法见P428-429 API注释

## 7. 遗留的集合